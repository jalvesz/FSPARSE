#:include "common.fypp"
#:set KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
!>---------------------------------------------------
!> Copyright 2023-present Transvalor S.A. (JosÃ© R. Alves Z.)
!>
!> Use of this source code is governed by a MIT
!> license that can be found in the LICENSE.md file
!>---------------------------------------------------
module fsparse_conversions
    use fsparse_constants
    use fsparse_matrix_gallery
    implicit none
    
    interface dense2coo
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure dense2coo_${s1}$
    #:endfor
    end interface

    interface dense2diagonal
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure dense2diagonal_${s1}$
    #:endfor
    end interface

    interface coo2dense
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure coo2dense_${s1}$
    #:endfor
    end interface

    interface coo2diagonal
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure coo2diagonal_${s1}$
    #:endfor
    end interface

    interface coo2csr
        module procedure coo2csr_ordered
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure coo2csr_ordered_${s1}$
    #:endfor
    end interface

    interface csr2coo
        module procedure csr2coo
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure csr2coo_${s1}$
    #:endfor
    end interface

    interface csr2diagonal
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure csr2diagonal_${s1}$
    #:endfor
    end interface

contains
    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine dense2coo_${s1}$(dense,COO)
        integer, parameter :: wp = ${k1}$
        ${t1}$, intent(in) :: dense(:,:)
        type(COO_${s1}$), intent(inout) :: COO
        integer :: num_rows, num_cols, nnz
        integer :: i, j, idx

        num_rows = size(dense,dim=1)
        num_cols = size(dense,dim=2)
        nnz = count( abs(dense) > tiny(1._wp) )

        call COO%malloc(num_rows,num_cols,nnz)

        idx = 1
        do i = 1, num_rows
            do j = 1, num_cols
                if(abs(dense(i,j)) < tiny(1._wp)) cycle
                COO%index(1,idx) = i
                COO%index(2,idx) = j
                COO%data(idx) = dense(i,j)
                idx = idx + 1
            end do
        end do
        COO%isOrdered = .true.
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine dense2diagonal_${s1}$(dense,diagonal)
        ${t1}$, intent(in) :: dense(:,:)
        ${t1}$, intent(inout) :: diagonal(:)
        integer :: num_rows
        integer :: i

        num_rows = size(dense,dim=1)
        do concurrent(i = 1:num_rows)
            diagonal(i) = dense(i,i)
        end do
    end subroutine

    #:endfor
    
    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine coo2dense_${s1}$(COO,dense)
        integer, parameter :: wp = ${k1}$
        type(COO_${s1}$), intent(in) :: COO
        ${t1}$, intent(inout) :: dense(:,:)
        integer :: idx

        do concurrent(idx = 1:COO%NNZ)
            dense( COO%index(1,idx) , COO%index(2,idx) ) = COO%data(idx)
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine coo2diagonal_${s1}$(COO,diagonal)
        integer, parameter :: wp = ${k1}$
        type(COO_${s1}$), intent(in) :: COO
        ${t1}$, intent(inout) :: diagonal(:)
        integer :: idx

        do concurrent(idx = 1:COO%NNZ)
            if(COO%index(1,idx)==COO%index(2,idx)) &
            & diagonal( COO%index(1,idx) ) = COO%data(idx)
        end do
    end subroutine

    #:endfor

    subroutine coo2csr_ordered(COO,CSR)
        !! coo2csr_ordered: This function enables transfering data from a COO matrix to a CSR matrix
        !! under the hypothesis that the COO is already ordered.
        type(COO_t), intent(in)    :: COO
        type(CSR_t), intent(inout) :: CSR
        integer :: i

        associate( nnz=>COO%nnz, num_rows=>COO%nrows, num_cols=>COO%ncols, base=>COO%base, sym=>COO%sym )
        CSR%NNZ = nnz; CSR%nrows = num_rows; CSR%ncols = num_cols
        CSR%base = base; CSR%sym = sym

        if( allocated(CSR%col) ) then
            CSR%col(1:nnz)  = COO%index(2,1:nnz)
            CSR%rowptr(1:num_rows) = 0
        else 
            allocate( CSR%col(nnz)  , source = COO%index(2,1:nnz) )
            allocate( CSR%rowptr(num_rows+1) , source = 0 )
        end if

        CSR%rowptr(1) = 1
        do i = 1, nnz
            CSR%rowptr( COO%index(1,i)+1 ) = CSR%rowptr( COO%index(1,i)+1 ) + 1
        end do
        do i = 1, num_rows
            CSR%rowptr( i+1 ) = CSR%rowptr( i+1 ) + CSR%rowptr( i )
        end do
        end associate
    end subroutine

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine coo2csr_ordered_${s1}$(COO,CSR)
        !! coo2csr_ordered: This function enables transfering data from a COO matrix to a CSR matrix
        !! under the hypothesis that the COO is already ordered.
        type(COO_${s1}$), intent(in)    :: COO
        type(CSR_${s1}$), intent(inout) :: CSR
        integer :: i

        associate( nnz=>COO%nnz, num_rows=>COO%nrows, num_cols=>COO%ncols, base=>COO%base, sym=>COO%sym )
        CSR%NNZ = nnz; CSR%nrows = num_rows; CSR%ncols = num_cols
        CSR%base = base; CSR%sym = sym

        if( allocated(CSR%col) ) then
            CSR%col(1:nnz)  = COO%index(2,1:nnz)
            CSR%rowptr(1:num_rows) = 0
            CSR%data(1:nnz) = COO%data(1:nnz)
        else 
            allocate( CSR%col(nnz)  , source = COO%index(2,1:nnz) )
            allocate( CSR%rowptr(num_rows+1) , source = 0 )
            allocate( CSR%data(nnz) , source = COO%data(1:nnz) )
        end if

        CSR%rowptr(1) = 1
        do i = 1, nnz
            CSR%rowptr( COO%index(1,i)+1 ) = CSR%rowptr( COO%index(1,i)+1 ) + 1
        end do
        do i = 1, num_rows
            CSR%rowptr( i+1 ) = CSR%rowptr( i+1 ) + CSR%rowptr( i )
        end do
        end associate
    end subroutine

    #:endfor
    
    subroutine csr2coo(CSR,COO)
        !! csr2coo: This function enables transfering data from a CSR matrix to a COO matrix
        type(CSR_t), intent(in)    :: CSR
        type(COO_t), intent(inout) :: COO
        integer :: i, j

        COO%NNZ = CSR%NNZ; COO%nrows = CSR%nrows; COO%ncols = CSR%ncols
        COO%base = CSR%base; COO%sym = CSR%sym

        if( .not.allocated(COO%index) ) allocate( COO%index(2,CSR%NNZ) )
        
        do i = 1, CSR%nrows
            do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                COO%index(1:2,j) = [i,CSR%col(j)]
            end do
        end do
    end subroutine

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine csr2coo_${s1}$(CSR,COO)
        !! csr2coo: This function enables transfering data from a CSR matrix to a COO matrix
        type(CSR_${s1}$), intent(in)    :: CSR
        type(COO_${s1}$), intent(inout) :: COO
        integer :: i, j

        COO%NNZ = CSR%NNZ; COO%nrows = CSR%nrows; COO%ncols = CSR%ncols
        COO%base = CSR%base; COO%sym = CSR%sym

        if( .not.allocated(COO%data) ) then
            allocate( COO%data(CSR%NNZ) , source = CSR%data(1:CSR%NNZ) )
        else 
            COO%data(1:CSR%NNZ) = CSR%data(1:CSR%NNZ)
        end if

        if( .not.allocated(COO%index) ) allocate( COO%index(2,CSR%NNZ) )
        
        do i = 1, CSR%nrows
            do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                COO%index(1:2,j) = [i,CSR%col(j)]
            end do
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine csr2diagonal_${s1}$(CSR,diagonal)
        integer, parameter :: wp = ${k1}$
        type(CSR_${s1}$), intent(in) :: CSR
        ${t1}$, intent(inout) :: diagonal(:)
        integer :: i, j
        select case(CSR%sym)
        case(k_SYMTRIINF)
            do i = 1, CSR%nrows
                diagonal(i) = CSR%data( CSR%rowptr(i+1)-1 )
            end do
        case(k_SYMTRISUP)
            do i = 1, CSR%nrows
                diagonal(i) = CSR%data( CSR%rowptr(i) )
            end do
        case(k_NOSYMMETRY)
            do i = 1, CSR%nrows
                do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                    if( CSR%col(j) == i ) then
                        diagonal(i) = CSR%data(j)
                        exit
                    end if
                end do
            end do
        end select
    end subroutine

    #:endfor
    
end module fsparse_conversions